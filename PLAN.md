# План: apiv2 для простого звонка (WASM UI без авторизации)

## Цель
Сделать набор новых серверных эндпоинтов для **максимально простого сценария звонка между двумя клиентами** (A и B) **без авторизации**, для будущего WASM UI.

UI/страницы (HTML маршруты) в этом плане **не описываются** (по запросу). Речь только про серверные адреса и их назначение.

## Ограничения и требования
- Без авторизации: **нет JWT, нет логина**, никаких user accounts.
- Только один базовый сценарий:
  - Клиент A начинает звонок, остаётся в ожидании.
  - Клиент B открывает страницу, видит текущий звонок и присоединяется.
  - После присоединения идёт WebRTC звонок между двумя участниками.
- TURN/STUN конфиг берём **из существующего эндпоинта**: `GET /api/turn-config`.
- Новые HTTP API эндпоинты должны начинаться с префикса **`/apiv2`**.

## Уже существующий эндпоинт (переиспользуем)
- `GET /api/turn-config`
  - Возвращает `iceServers` для WebRTC (STUN+TURN) и креды TURN.
  - Используется обоими клиентами (A и B) при создании `RTCPeerConnection({ iceServers })`.

## Расположение нового кода

- Эндпоинты из apiv2 следует расположить server/internal/handlersv2
- Если вносятся изменения в существующие эндпоинты, то переносить их не надо
- Новые модели следует разместить в server/internal/models, но в новых файлах

## Новые эндпоинты apiv2

### 1) Управление звонком (простая «комната» на двоих)

- `POST /apiv2/calls`
  - Назначение: создать новый звонок/комнату.
  - Кем вызывается: Клиент A при нажатии «начать звонок».
  - Внутри использует библиотеку nanoid для генерации id звонка
  - Ответ (пример):
    - `200 OK`
    - `{ "call_id": "<id>", "status": "waiting" }`

- `GET /apiv2/calls/:call_id`
  - Назначение: состояние конкретного звонка.
  - Ответ (пример):
    - `200 OK` + `{ "call_id": "<id>", "status": "waiting"|"active"|"ended", "participants": { "count": 0|1|2 } }`

- `POST /apiv2/calls/:call_id/join`
  - Назначение: присоединиться к существующему звонку.
  - Кем вызывается: Клиент B при нажатии «присоединиться».
  - Ответ (пример):
    - `200 OK` + `{ "call_id": "<id>", "peer_id": "<peer_id>" }`
  - Примечание: `peer_id` — это **не авторизация**, а идентификатор участника в рамках звонка.

- (опционально, но полезно) `POST /apiv2/calls/:call_id/leave`
  - Назначение: явный выход из звонка (если нужно корректно завершать состояние без ожидания таймаутов WS).

### 2) Сигналинг WebRTC (WebSocket)

- `GET /apiv2/ws?call_id=<call_id>&peer_id=<peer_id>`
  - Назначение: WebRTC сигналинг канал для SDP/ICE.
  - Авторизация: отсутствует. Сервер доверяет `call_id/peer_id` как «ключам комнаты».

**Сообщения по WS (минимум)**
- `join` — клиент подключился к комнате.
- `state` — сервер рассылает состояние (`waiting/active/ended`) + счётчик участников.
- `offer` — SDP offer от одного участника к другому.
- `answer` — SDP answer.
- `ice-candidate` — ICE candidate.
- `leave` — участник ушёл.

**Правила комнаты**
- Максимум **2** участника.
- Первый участник -> `waiting`.
- Второй участник -> `active`, далее идёт обмен `offer/answer/ice-candidate`.
- Если один ушёл -> можно переводить в `ended` или обратно в `waiting` (решение зависит от желаемого UX; для MVP проще `ended`).

## Идеальный порядок вызовов (с точки зрения клиента)

### Клиент A (инициатор)
1) `POST /apiv2/calls` → получает `call_id`.
2) Открывает WS: `GET /apiv2/ws?call_id=<call_id>&peer_id=<peer_id>`.
3) `GET /api/turn-config` → получает `iceServers`.
4) Поднимает `RTCPeerConnection` и ждёт второго участника.
5) После появления B:
   - A создаёт `offer` → шлёт по WS,
   - принимает `answer`,
   - параллельно обменивается `ice-candidate`.

### Клиент B (присоединяющийся)
1) Получает `call_id` из приглашения/ссылки (или будущего списка звонков).
2) `POST /apiv2/calls/:call_id/join` → получает `peer_id`.
3) Открывает WS: `GET /apiv2/ws?call_id=<call_id>&peer_id=<peer_id>`.
4) `GET /api/turn-config` → получает `iceServers`.
5) Получает `offer` по WS → отвечает `answer` → обменивается `ice-candidate`.

## Серверное состояние (минимально)
Для реализации адресов выше серверу нужна сущность «звонок»:
- `call_id`
- `status`: `waiting|active|ended`
- `participants`: 0..2 (у каждого `peer_id`, `connected_at`, `ws_connected`)
- TTL/cleanup (авто-удаление/завершение после N минут без активности)

Хранилище: для MVP достаточно in-memory (без БД), т.к. нет аккаунтов/авторизации.

## Не входит в план (сознательно)
- UI/страницы, дизайн, роутинг фронтенда.
- Безопасность/анти-абьюз (капча, rate limit, pin-коды) — можно добавить позже.
- Push/уведомления.

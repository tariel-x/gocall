# План: поддержка нескольких одновременных звонков в apiv2

## Цели
- Убрать ограничение на единственный «текущий звонок» и разрешить создавать новые call_id при каждом `POST /apiv2/calls`.
- Обеспечить корректную работу сигналинга и REST-эндпоинтов, когда параллельно существует несколько комнат в разных статусах.
- Сохранить обратную совместимость фронтенда: старые вызовы API должны продолжить работать (возвращая новый call_id или список доступных звонков, если требуется).

## Статус на 14.01.2026
- `CallStore` переписан: каждый `POST /apiv2/calls` создаёт новую комнату, введены индексы по статусам, очистка TTL и unit-тесты.
- Эндпоинт `GET /apiv2/calls/current` удалён как неиспользуемый; клиенты получают `call_id` через ссылки/инвайты или будущие списки.
- WS-хаб продолжает работать с множеством комнат и теперь закрывает heartbeat при исчезновении call.

## Исходные ограничения
- В [server/internal/handlersv2/store.go](server/internal/handlersv2/store.go) хранится один `currentCallID`. `CreateCall` возвращает `ErrCallAlreadyExist`, пока предыдущий звонок не перешёл в `ended`.
- `GET /apiv2/calls/current` смотрит только на `currentCallID`, поэтому не может выбрать конкретный звонок среди нескольких ожидающих.
- WebSocket-хаб [server/internal/handlersv2/ws_hub.go](server/internal/handlersv2/ws_hub.go) уже поддерживает множество call_id (map `callID -> peerID -> client`), т.е. узким местом является только стор и REST-слой.

## Предлагаемые изменения

### 1. Хранилище звонков
- Перестроить `CallStore` так, чтобы `CreateCall` **всегда** создавал новую запись:
  - Удалить поле `currentCallID` и связанный код.
  - Добавить индекс/список активных звонков (например, `waitingCalls []string` или `map[string]struct{}`) для быстрого поиска.
  - Ввести метод `ListCalls(filter)` для выборки по статусу (`waiting`, `active`).
  - При `EndCall` и `maybeExpireLocked` удалять запись из списка активных, но сам `call` можно держать в map до явной очистки по TTL.
  - Добавить периодический cleanup (возможно, через вызов из handler'ов) для удаления `ended` звонков старше TTL, чтобы map не росла бесконечно.

### 2. REST API
- `POST /apiv2/calls`:
  - Всегда возвращать `200`/`201` с новым `call_id`. Ошибка `409` больше не используется для «у вас уже есть звонок».
  - Опционально добавить query `?reuse_last=true`, если вдруг нужно сохранить старую семантику (по умолчанию off).
- `GET /apiv2/calls/current` (удалён):
  - Был проверен и не использовался фронтендом, поэтому вырезан из роутинга.
  - Клиенты теперь всегда работают с конкретным `call_id` из ссылки или отдельного списка.

### 3. Присоединение и валидация
- `Join(callID)` уже изолирован по `callID`, менять не нужно, но стоит убедиться, что:
  - Host может параллельно держать несколько звонков (каждый со своим peer_id). Для этого `CreateCall` должен сразу выдавать уникальный host `peer_id` или хранить их в map `hostPeerIDs[callID]`.
  - `EnsureHostPeerID` должен работать независимо для каждого call_id и не пересекаться.
- Продумать поведение при переполнении (больше 2 участников): сейчас возвращает `ErrCallFull`, оставить как есть.

### 4. Сигналинг / WS
- Текущая реализация already keyed by `callID` → требует только убедиться, что `broadcastState` отправляет state конкретной комнаты.
- Добавить в state payload, кроме `participants.count`, ещё `call_id`, чтобы клиенты не путали сообщения при подписке на несколько звонков (если такое появится).
- Обновить heartbeat: при ошибке получения call (например, ручка вернула `ErrCallNotFound` после удаления) нужно закрывать соединение клиента, чтобы не повисал.

### 5. Управление TTL
- Сейчас TTL продлевается при активных действиях. Для мультизвонков важно иметь явный фоновой `cleanup`, иначе map `calls` будет накапливаться:
  - Запускать `go`-рутину в `NewCallStore`, которая каждые N минут вызывает `cleanupExpired()`. N пусть будет равна по-умолчанию 3 часа.
- Решить судьбу `ended` звонков: удалять сразу после `EndCall`.

### 6. Изменения на фронте (для согласованности)
- После того как сервер начнёт всегда выдавать новый `call_id`, фронту нужно:
  - Перестать интерпретировать `409` как сигнал «уже есть звонок», т.к. он исчезнет.
- Эти фронтовые задачи занесём отдельным пунктом, но в этом плане отмечаем потребность в API-совместимости.

## Пошаговый план
1. **Рефакторинг CallStore**
   - Удалить `currentCallID`, переписать `CreateCall`, `GetCurrent`, `maybeExpireLocked`.
   - Добавить новый метод `listByStatus(status models.CallStatusV2, limit int)`.
   - Покрыть unit-тестами случаи «несколько звонков подряд», «параллельные Join в разных комнатах».
2. **Обновление REST хэндлеров**
   - `CreateCall` → всегда 200/201, никаких `ErrCallAlreadyExist`.
   - `GetCurrentCall` → проверить и удалить, либо предложить варианты по изменению фронта.
3. **WS и state**
   - Перепроверить, что `broadcastState` вызывается только для одной комнаты.
   - Добавить graceful закрытие, если комната удалена.
4. **Очистка и TTL**
   - Решить стратегию удаления завершённых звонков, реализовать `cleanupExpired`.
   - При запуске сервера прогревать стор (никаких наследованных «current» значений).
5. **Документация и контракт**
   - Обновить README/PLAN.md с новой семантикой API.
   - Описать миграцию для фронта: что `POST /apiv2/calls` теперь всегда создаёт новую комнату.
6. **Проверка end-to-end**
   - Запустить два звонка параллельно, убедиться, что каждое соединение использует свой WS и не мешает друг другу.
   - Проверить ситуацию, когда один звонок заканчивается, а второй продолжает работать.

## Риски и вопросы
- При параллельных звонках важно гарантировать, что генерация peer_id уникальна (gorilla nanoid уже даёт хороший рандом, но стоит убедиться, что нет повторного использования peer_id между звонками, особенно для инициатора).

## Критерии готовности
- `POST /apiv2/calls` возвращает новый ID при каждом запросе, даже если есть активные звонки.
- Два разных `call_id` могут существовать в статусе `waiting/active` одновременно, сигналинг и REST работают независимо.
- TTL и cleanup не позволяют старым звонкам блокировать создание новых.

# План: простейший UI для звонков на базе React + Tailwind + штатный WebRTC

## Цель
Сделать минимальный UI для звонков на базе **React** (SPA) с **четырьмя экранами** (отдельные URL), используя **штатный WebRTC стек браузера** (`getUserMedia`, `RTCPeerConnection`) и текущий подход к сигналингу/ICE.

Требуемые экраны:
1) Форма начала звонка (отдельный URL) — одна кнопка.
2) Экран ожидания подключения — статус ожидания, без UI звонка; **по возможности** запросить доступ к камере/микрофону уже здесь.
3) Экран присоединения (отдельный URL) — одна кнопка «подключиться»; **по возможности** запросить доступ к камере/микрофону уже здесь.
4) Экран звонка — общий для обоих, визуально как текущий в `server/web`: удалённое видео крупно, своё — маленьким блоком (можно не плавающим, чтобы меньше кода).

## Опора на текущую реализацию WebRTC
Ориентируемся на текущий веб-клиент [server/web/app.js](server/web/app.js):
- Медиа: `navigator.mediaDevices.getUserMedia({ audio: true, video: ... })`.
- PeerConnection: `new RTCPeerConnection(rtcConfig)` где `rtcConfig` загружается через `GET /api/turn-config`.
- Треки: `pc.addTrack(track, localStream)`.
- ICE: `pc.onicecandidate => send({ type: 'ice-candidate', data: candidate })`.
- Remote: `pc.ontrack => remoteVideo.srcObject = event.streams[0]`.
- SDP:
  - инициатор: `createOffer` → `setLocalDescription` → отправка `offer`.
  - принимающий: `setRemoteDescription(offer)` → `createAnswer` → `setLocalDescription` → отправка `answer`.

В react UI повторяем тот же подход, без сторонних WebRTC библиотек.

Дополнение: **основа для реализации уже есть в server/web** — там есть примерный роутинг и два пустых экрана-заготовки. При реализации react UI нужно опираться на эти заготовки/потоки (сигналинг, порядок вызовов, работу с медиа) и переносить только необходимое, сохраняя минимальный объём кода.

## URL-структура UI (React)
Конкретные пути можно выбрать любые; ниже — предлагаемый минимальный набор:
- `/newui/` — экран 1 (начать звонок).
- `/newui/wait` — экран 2 (ожидание подключения).
- `/newui/join` — экран 3 (присоединиться).
- `/newui/call` — экран 4 (звонок).

Примечание: экраны «start» и «join» — это отдельные URL (как требуется), а «call» — общий.

## Связь с сервером (минимально)
### HTTP
- TURN конфиг: используем существующий `GET /api/turn-config`.
- Для управления звонком используем адреса из плана PLAN.md (apiv2), чтобы было 2 клиента без авторизации:
  - `POST /apiv2/calls`
  - `POST /apiv2/calls/:call_id/join`
  - (опционально) `GET /apiv2/calls/:call_id`

### WebSocket
- Сигналинг: `GET /apiv2/ws?call_id=<call_id>&peer_id=<peer_id>`
- Сообщения: `offer`, `answer`, `ice-candidate`, плюс `state/join/leave` при необходимости.

## Поведение экранов

Нужно реализовать роутинг как SPA (без перезагрузки страницы): меняется только маршрут. Для этого использовать React Router (или аналогичный роутер).
При этом при переходе по прямому адресу должен открываться нужный экран (сервер должен отдавать один и тот же `index.html` для `/newui/*`).

Если по каким-то причинам SPA fallback на сервере сделать невозможно — использовать запасной вариант: передавать нужные параметры через query-строку и/или хранить состояние в `localStorage`/`sessionStorage`. Важно, чтобы это работало в максимально широком наборе браузеров.

### Экран 1: `/newui` (кнопка «Начать звонок»)
Минимальная логика:
- UI: одна кнопка.
- На click:
  1) (по желанию) можно запросить медиа сразу тут, но по требованиям это важнее для `wait`/`join`. Можно оставить без.
  2) `POST /apiv2/calls` → получить `call_id`.
  3) Перейти на `/newui/wait/:call_id`.

Примечание про разрешения: большинство браузеров надёжнее дают `getUserMedia` только по user-gesture (клик). Поэтому допустимая стратегия — **начать запрашивать камеру/микрофон на экране ожидания, но инициировать это через явное действие пользователя**, если автозапрос не проходит.

### Экран 2: `/newui/wait/:call_id` (ожидание)
UI:
- Текст статуса: «Ожидается подключение собеседника…»
- (опционально) текст по разрешениям: «Запрашиваем доступ к камере и микрофону… / Доступ получен»
- Полная ссылка на присоединение к звонку в input, чтобы её можно было просто копировать (кнопка копирования не нужна).
- Техническая информация о том, какой сейчас статус звонка, какой статус собеседника, поддерживается ли всё ещё ws соединение с сервером.

Логика:
- При входе:
  1) Проверить наличие `call_id`.
  2) Открыть WS `GET /apiv2/ws?...` (если по серверному контракту нужен `peer_id`, то получить/сгенерировать его на стороне клиента или завести отдельный join для инициатора — зависит от реализации apiv2; в плане UI считаем, что инициатор тоже имеет `peer_id`).
  3) Начать получать `state` (waiting/active).
  4) **Запросить `getUserMedia` как можно раньше**:
     - Вариант А (идеальный UX): запрос при монтировании страницы. (Может блокироваться на некоторых платформах.)
     - Вариант Б (надёжный): показать кнопку "Разрешить камеру и микрофон" и вызвать `getUserMedia` по клику; при успехе обновить статус.

Переход в звонок:
- Когда сервер/WS сообщает, что второй участник подключился (например `state: active`), перейти на `/newui/call/:call_id`.

### Экран 3: `/newui/join/:call_id` (кнопка «Подключиться»)
UI:
- Одна кнопка «Подключиться».
- ID звонка берётся из параметра URL.

Логика:
- При открытии страницы:
  - `GET /apiv2/calls/:call_id` → если 404, показать статус «Звонок не найден».
- По кнопке «Подключиться» (если `call_id` найден):
  1) **Запросить `getUserMedia` максимально рано** (см. варианты A/B выше).
  2) `POST /apiv2/calls/:call_id/join` → получить `peer_id`.
  3) Открыть WS `/apiv2/ws?call_id=...&peer_id=...`.
  4) Перейти на `/newui/call/:call_id`.

### Экран 4: `/newui/call/:call_id` (сам звонок)
UI (Tailwind, минимум):
- Большой блок `<video>` для remote.
- Маленький блок `<video>` для local (можно просто отдельным блоком под/над основным, без overlay, чтобы меньше CSS/кода).
- Минимальная кнопка «Завершить» (опционально, но практически нужна), без остальных контролов.

Логика WebRTC:
- На входе:
  1) `GET /api/turn-config` → сформировать `rtcConfig`.
  2) Если `localStream` ещё не получен на предыдущих экранах — запросить `getUserMedia`.
  3) Создать `pc = new RTCPeerConnection(rtcConfig)`.
  4) `addTrack` для всех треков local.
  5) Навесить:
     - `pc.onicecandidate` → отправлять `ice-candidate` по WS.
     - `pc.ontrack` → назначить `remoteVideo.srcObject`.
  6) В зависимости от роли:
     - `caller`: `createOffer` → `setLocalDescription` → отправить `offer`.
     - `callee`: ждать `offer` по WS.
- Обработка WS:
  - `offer`: `setRemoteDescription(offer)` → `createAnswer` → `setLocalDescription(answer)` → отправить `answer`.
  - `answer`: `setRemoteDescription(answer)`.
  - `ice-candidate`: `pc.addIceCandidate(candidate)`.

Ограничение: UI «без непосредственно экрана звонка» для join/wait означает, что `<video>` элементы и `pc` можно создавать только на `/newui/call`. Но получение `getUserMedia` (разрешений и `MediaStream`) допускается раньше.

## TailwindCSS (план подключения)
Цель — использовать Tailwind для вёрстки React UI без усложнения рантайма.

Подход (самый простой для проекта):
- Подключить Tailwind в сборку React-приложения (например, через Vite/Webpack).
- На выходе получаем статические файлы (`index.html`, JS, CSS), которые сервер отдаёт под `/newui/*`.

Минимальные шаги:
1) Добавить Tailwind как dev-зависимость в React-проект.
2) Добавить конфиг Tailwind (`tailwind.config.*`) с `content`, указывающим на исходники React (компоненты/страницы).
3) Добавить входной CSS (например `src/index.css`) с `@tailwind base; @tailwind components; @tailwind utilities;`.
4) Настроить сборку так, чтобы артефакты попадали в статический каталог сервера и раздавались под `/newui/*`.

## Структура кода React UI (минимум сущностей)
- `StartPage` — экран создания звонка `/`.
- `WaitPage` — экран `/wait`.
- `JoinPage` — экран `/join`.
- `CallPage` — экран `/call`.

Сервисы (чтобы не размазывать WebRTC по компонентам):
- `apiClient`:
  - `CreateCall()`
  - `GetCurrentCall()`
  - `JoinCall(callID)`
  - `GetTurnConfig()`
- `signalingClient`:
  - `Connect(callID, peerID)`
  - `Send(type, payload)`
  - `OnMessage(handler)`
- `webrtcSession`:
  - `AcquireMedia(callType)`
  - `CreatePeerConnection(rtcConfig)`
  - `StartAsCaller()` / `StartAsCallee()`
  - `HandleOffer/HandleAnswer/HandleIceCandidate`

Важно: это план по структуре; конкретная декомпозиция может быть упрощена до 1-2 файлов, если хочется совсем минимум.

## Тонкости браузера (учесть в реализации)
- `getUserMedia` часто требует user-gesture. Поэтому «запросить доступ на wait/join экране» лучше реализовать как:
  - попытка автозапроса при входе,
  - если браузер отказал по политике — показать кнопку «Разрешить камеру/микрофон».
- На мобильных важно ставить `playsinline` для `<video>` (как в [server/web/index.html](server/web/index.html)).
- Для автозапуска воспроизведения может понадобиться явный `video.play()` после назначения `srcObject`.

## Минимальный чек-лист готовности
- `/newui` → создаёт звонок → редиректит на `/newui/wait/:call_id`.
- `/newui/wait/:call_id` → показывает статус ожидания + получает разрешения на устройства (если возможно).
- `/newui/join/:call_id` → находит текущий звонок + по кнопке присоединяется и получает разрешения.
- `/newui/call/:call_id` → создаёт `RTCPeerConnection`, обменивается SDP/ICE по WS, показывает remote/local видео.
- Вёрстка всех экранов только Tailwind-классами.

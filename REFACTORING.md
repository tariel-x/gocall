# План рефакторинга: уменьшить количество `useEffect` в `CallPage.tsx`

Цель: сократить число `useEffect` в `frontend/src/pages/CallPage.tsx`, уменьшить «синхронизационные» эффекты (когда эффект лишь перекладывает данные из одного состояния в другое), снизить риск гонок и сделать логику звонка проще для сопровождения.

Ограничения (важно):
- Никакой новой функциональности/UX.
- Сохранить текущие сценарии: host/guest роли, сигналинг, WebRTC, обновление статусов, teardown при уходе.
- В ходе рефакторинга стараться не менять внешние сервисы (`services/*`) без необходимости.

---

## 1) Инвентаризация текущих `useEffect` и их типы

В текущем `CallPage.tsx` эффекты условно делятся на 4 категории:

1) **Сайд-эффекты инфраструктуры (инициализация/cleanup)**
   - Инициализация звонка по `callId`: локальная медиа, TURN-конфиг, создание `RTCPeerConnection`, подписка на сигналинг, назначение обработчиков, teardown при unmount.

2) **Привязка медиа к DOM**
   - Привязка локального/удалённого `MediaStream` к `<video>` через `srcObject` + `play()`.

3) **Derived state / UI сообщения**
   - Эффекты, которые выставляют `infoMessage` на основе `remoteStream/error`.
   - Эффекты, которые выставляют `infoMessage` на основе комбинации `callStatus`, `peerConnectionState`, `iceConnectionState`.

4) **Оркестрация (автоматизация шагов)**
   - Эффект, который у host создаёт offer при готовности условий (`participants`, `wsState`, `offerSentRef`).

Главная идея: оставить эффекты только там, где реально требуется side-effect (внешний мир / DOM), а всё, что является производным состоянием, вычислять без `setState`.

---

## 2) Целевой дизайн: «1 подсистема → 1 хук → 1 эффект (максимум)»

Идеальный итог для `CallPage`:
- В `CallPage` остаются:
  - вызов `useCallSession(callId)` (внутри: вся инициализация/teardown звонка)
  - вызов(ы) `useVideoElement(ref, stream, opts)` для local/remote видео
  - рендер и минимальная логика обработчиков кнопок
- Количество `useEffect` в самом компоненте падает до ~0–2 (потому что видео-хук тоже может быть одним эффектом, но он вынесен).

---

## 3) Шаг 1 — Вынести привязку `MediaStream → <video>` в один переиспользуемый хук

### Почему это уменьшает `useEffect`
Сейчас два эффекта делают почти одно и то же для local/remote. Это классический кандидат на объединение.

### API (пример)

```ts
function useVideoElement(
  ref: React.RefObject<HTMLVideoElement>,
  stream: MediaStream | null,
  options?: { muted?: boolean; playsInline?: boolean }
): void
```

### Поведение
- Если `ref.current` отсутствует — ничего не делать.
- Проставить `playsInline`, `muted`.
- Установить `video.srcObject = stream ?? null`.
- Если `stream` есть — вызвать `video.play()` и подавить ошибки автоплея.

### Результат
- В `CallPage` убираются 2 эффекта, заменяются 2 вызовами хука.

---

## 4) Шаг 2 — Объединить «сцепленное состояние» через `useReducer`

### Проблема сейчас
Много `useState`, которые меняются совместно и часто зависят друг от друга:
- `wsState`, `callStatus`, `participants`
- `peerConnectionState`, `iceConnectionState`, `mediaRoute`
- `remoteStream`, `localStreamState`
- `infoMessage`, `error`

Это приводит к:
- множеству мелких сеттеров,
- повышенному риску «рассинхрона» (например, `infoMessage` меняется в одном месте, а `callStatus` — в другом),
- дополнительным `useEffect`, которые обслуживают derived state.

### Целевой подход
- Ввести `CallState` и `callReducer`.
- Все входящие события из WebRTC/сигналинга превращать в `dispatch({ type: ... })`.

### Набросок событий (пример)
- `INIT_START`
- `LOCAL_MEDIA_READY` / `LOCAL_MEDIA_ERROR`
- `TURN_CONFIG_READY` (опционально)
- `SIGNALING_READY` / `SIGNALING_DISCONNECTED`
- `CALL_STATE_UPDATE` (status + participants)
- `PC_STATE_UPDATE`
- `ICE_STATE_UPDATE`
- `REMOTE_STREAM_READY`
- `MEDIA_ROUTE_UPDATE`
- `TEARDOWN`

### Результат
- Логика изменения состояния становится централизованной.
- Упрощается перенос оркестрации (например, авто-offer) ближе к обработчикам событий.

---

## 5) Шаг 3 — Убрать эффекты, которые выставляют `infoMessage` как derived state

### Проблема сейчас
`infoMessage` — по сути отображение статуса системы. Если он вычисляемый, не нужно хранить его отдельным `useState` и обновлять через эффекты.

### Варианты решения

#### Вариант A (самый простой): вычислять `infoMessage` в рендере
- Сделать функцию `getInfoMessage(state)` и возвращать строку по приоритетам.
- Приоритеты обычно такие:
  1) `error` → показываем ошибку (и/или отдельный блок ошибки уже есть)
  2) `callStatus === 'ended'` → «Звонок завершён»
  3) `remoteStream !== null` → «Видео собеседника подключено»
  4) `callStatus==='active' && pc connected && ice connected/completed` → «Соединение установлено»
  5) иначе → «Готовим звонок…» / «Ждём подключение…» и т.д.

Плюсы: минимум кода.
Минусы: если есть «одноразовые» сообщения, которые не должны перезатираться (например, «Отправили ответ…»), нужен механизм приоритетов.

#### Вариант B: хранить не строку, а «последнее событие/фазу»
- Вместо `infoMessage: string` держать `uiPhase: 'preparing' | 'waiting' | 'answer-sent' | ...`.
- Текст брать из мапы.

Плюсы: лучше управляемость.
Минусы: чуть больше структуры.

### Результат
- Убираются минимум 2 эффекта, обслуживающих `infoMessage`.

---

## 6) Шаг 4 — Свести ref-синхронизацию к минимуму (`remoteStreamRef`, `connectionParamsRef`)

### Проблема
Сейчас есть эффекты, которые «копируют» state в `ref`, чтобы обработчики внутри подписок видели актуальные значения.

### Более чистые альтернативы

#### Альтернатива A: «stable callback / useEvent pattern»
- Создать утилитный хук `useEvent(fn)`, который возвращает стабильную функцию, читающую актуальный `fn` из `ref`.
- Тогда обработчики сигналинга можно подписать один раз, но внутри они будут вызывать актуальные колбэки.

#### Альтернатива B: держать “runtime” данные в редьюсере и обновлять их событиями
- Например, `remoteStream` приходит как событие `REMOTE_STREAM_READY`, и уже из этого состояния можно решать, что показать.

#### Альтернатива C: ограничиться одним ref для “runtime”
- Если рефы неизбежны (например, `pcRef`, `signalingRef`), оставить только их.
- Убрать рефы, обслуживающие UI/derived state.

### Результат
- Меньше эффекта ради `remoteStreamRef.current = remoteStream`.
- Меньше неявной логики зависимости.

---

## 7) Шаг 5 — Перенести «auto-offer для host» из `useEffect` в событийную оркестрацию

### Проблема сейчас
Есть эффект:
- если host
- и `participants >= 2`
- и `wsState === 'ready'`
- и offer ещё не отправлен
→ `createOffer()`

Эта логика — не UI-реакция на рендер, а часть протокола (оркестрация). Её лучше держать рядом с источником событий.

### Варианты переноса

#### Вариант A: проверка внутри обработчиков сигналинга
- В `onJoin` и/или `onState` после обновления `participants/wsState` проверить условия и вызвать `createOffer()`.

#### Вариант B: «команда» через редьюсер
- Редьюсер выставляет флаг `shouldCreateOffer` когда условия выполнены.
- Один эффект внутри `useCallSession` наблюдает за этим флагом и исполняет side-effect `createOffer()`.

### Результат
- Убирается ещё один `useEffect` из `CallPage`.
- Протокол становится более локальным и предсказуемым.

---

## 8) Шаг 6 — Сконцентрировать весь lifecycle звонка в `useCallSession(callId)`

### Что должен делать `useCallSession`
- Инициализация:
  - validate `callId` и session role/peerId (где сейчас ставится `error`)
  - `setCallContext(callId)`
  - `acquireLocalMedia()` → обновить state
  - `fetchTurnConfig()` → создать `RTCPeerConnection` с iceServers
  - `pc.addTrack(...)`
  - установить обработчики `pc.onicecandidate`, `pc.ontrack`, `pc.onconnectionstatechange`, `pc.oniceconnectionstatechange`
  - `subscribeToSignaling(...)` и обработчики сообщений
- Teardown:
  - отписка от сигналинга
  - закрыть ws client (в зависимости от сценария)
  - закрыть `RTCPeerConnection`
  - `releaseLocalStream()`

### Что должен возвращать наружу
Минимальный «контракт» между хукoм и UI:
- `state`: всё, что нужно для рендера (статусы, participants, streams, error)
- `actions`: например `hangup()` или `leaveToHome()` если нужно
- refs можно не отдавать наружу

Рекомендация: `CallPage` должен быть максимально «тупым» (UI-only), а вся “машина состояний звонка” — внутри `useCallSession`.

---

## 9) Предлагаемая последовательность внедрения (самая безопасная)

1) **Вынести `useVideoElement`** (минимальный риск, легко откатить).
2) **Убрать derived `infoMessage` эффекты** (перейти на вычисление или uiPhase).
3) **Вынести lifecycle в `useCallSession`** без `useReducer` (можно сначала просто перенести эффекты внутрь хука).
4) **Перейти на `useReducer`** (самое крупное изменение) и заменить множество `setState` на `dispatch`.
5) **Перенести auto-offer** из эффекта в оркестрацию событий.
6) **Почистить ref-синхронизации** (удалить `remoteStreamRef`/лишние ref, если они больше не нужны).

Такой порядок снижает вероятность «сломать всё сразу».

---

## 10) Критерии готовности (как проверить, что всё ок)

- Количество `useEffect` в `CallPage.tsx` заметно уменьшилось (идеально: 0–2).
- Нет потери сценариев:
  - host может дождаться гостя и установить соединение
  - guest может принять offer и отправить answer
  - ICE candidate обмен работает
  - teardown корректно освобождает камеру/микрофон
- UI статусы (`wsState`, `WebRTC`, `ICE`, `Медиа-канал`, `Участники`) продолжают корректно обновляться.
- `infoMessage` не «прыгает» и не перетирает более важные сообщения.

---

## 11) Набросок структуры файлов (опционально)

Если захотите разнести по файлам (не обязательно):
- `frontend/src/hooks/useVideoElement.ts`
- `frontend/src/hooks/useCallSession.ts`
- (опционально) `frontend/src/pages/callReducer.ts`

---

Если потребуется, могу подготовить следующий документ: «минимальный интерфейс `useCallSession` (какие поля state/actions нужны текущему UI)» — чтобы сам рефакторинг прошёл без сюрпризов.

# STEP 1: Создание единого состояния звонка (Unified State)

### Общая задача рефакторинга
Наша цель — упростить код видеозвонков так, чтобы он был понятен любому разработчику, даже без глубоких знаний TypeScript и WebRTC. Мы убираем сложные технические детали "под капот" и оставляем снаружи только простую и понятную логику (принцип KISS). Мы также убираем дублирование кода (принцип DRY).

---

### Что делаем в этом шаге
Мы создаем единый список состояний (Enum), который описывает всё, что может происходить со звонком.

### Зачем это нужно
Сейчас состояние звонка "размазано" по разным переменным:
- Работает ли веб-сокет (`wsState`)?
- Есть ли соединение между компьютерами (`iceConnectionState`)?
- Подключился ли собеседник (`peerConnectionState`)?
- Какая роль у пользователя (`host` или `guest`)?

Разработчику интерфейса (UI) сложно в этом разобраться. Ему нужно просто знать: "Мы соединяемся?", "Мы уже говорим?", "Произошла ошибка?".
Мы создадим один тип `AppCallState`, который ответит на эти вопросы.

### Какие файлы меняем
- `frontend/src/services/types.ts`

### Пример кода

В файл `frontend/src/services/types.ts` нужно добавить новый тип (или заменить существующий `CallStatus`).

```typescript
// frontend/src/services/types.ts

// Простое и понятное состояние звонка для UI
export type AppCallState = 
  | 'IDLE'              // Ничего не происходит (начальное состояние)
  | 'MEDIA_LOADING'     // Запрашиваем камеру и микрофон
  | 'SIGNALING_CONNECT' // Подключаемся к серверу (WebSocket)
  | 'WAITING_FOR_PEER'  // Ждем, пока зайдет собеседник (или пока он ответит)
  | 'NEGOTIATING'       // Техническая магия: компьютеры "договариваются" о соединении
  | 'ACTIVE'            // Звонок идет, видео и звук передаются
  | 'RECONNECTING'      // Связь прервалась, пытаемся восстановить
  | 'COMPLETED'         // Звонок завершен нормально
  | 'FAILED';           // Произошла неустранимая ошибка

// Интерфейс для общей информации о сессии, который будет отдавать хук
export interface CallSessionState {
  status: AppCallState;      // Текущее состояние (самое важное)
  error: string | null;      // Текст ошибки, если есть
  isRemoteMuted: boolean;    // (Опционально) выключил ли собеседник звук
  // ... другие простые флаги
}
```

### Почему это упрощает жизнь
Теперь в UI компонентах не нужно писать сложные условия вроде:
`if (wsState === 'ready' && iceState === 'connected') { return 'Active' }`

Мы будем просто писать:
`if (status === 'ACTIVE') { ... }`

---

### Подробные подшаги выполнения

#### 1.1. Открытие файла типов
- **Что сделать**: Открыть файл `frontend/src/services/types.ts`.
- **Зачем**: Это место, где хранятся все общие определения типов данных приложения.
- **Как**: Найти файл в дереве проекта.

#### 1.2. Определение Enum состояний (AppCallState)
- **Что сделать**: Добавить экспортируемый тип `AppCallState` (как в примере выше).
- **Зачем**: Чтобы у нас был единый словарь всех возможных ситуаций в звонке.
- **Результат**: В файле появится `export type AppCallState = ...`.

#### 1.3. Определение интерфейса сессии (CallSessionState)
- **Что сделать**: Добавить интерфейс `CallSessionState`, использующий `AppCallState`.
- **Зачем**: Этот интерфейс будет "контрактом", который хук `useCallSession` обязуется возвращать.
- **Результат**: Появится `export interface CallSessionState { status: AppCallState; ... }`.

#### 1.4. Проверка на конфликты
- **Что сделать**: Убедиться, что новые имена не конфликтуют с существующими (например, `CallStatus`). Если старый `CallStatus` используется где-то еще, пока не удалять его, а просто добавить новые типы рядом.
- **Зачем**: Чтобы не сломать сборку проекта до того, как мы обновим остальные файлы.

# STEP 5: Отделение текстов от логики (Decouple UI Text)

### Общая задача рефакторинга
Наша цель — упростить код видеозвонков так, чтобы он был понятен любому разработчику. Принцип KISS говорит нам, что логика работы программы не должна смешиваться с тем, как она отображается пользователю.

---

### Что делаем в этом шаге
Мы убираем все строковые константы типа "Waiting for connection...", "Error: Camera not found" из хуков (`useCallSession`, `useWebRTCManager`) и выносим их в отдельную функцию-помощник (утилиту).

### Зачем это нужно
Сейчас, если мы захотим перевести приложение на английский или просто изменить текст сообщения "Собеседник отключился", нам придется лезть в самый сложный файл с логикой (`useCallSession.ts`) и искать там строку внутри какого-нибудь `useEffect`. Это опасно — можно случайно сломать логику.
Хуки должны возвращать **состояния** (коды), а UI компоненты должны превращать эти коды в **текст**.

### Какие файлы меняем
- Создаем новый файл `frontend/src/utils/callStatusUtils.ts` (или `.tsx` если нужны JSX элементы).

### Пример кода

```typescript
// frontend/src/utils/callStatusUtils.ts
import { AppCallState } from '../services/types';

// Простая функция: Код состояния -> Текст для пользователя
export function getCallStatusMessage(state: AppCallState): string {
  switch (state) {
    case 'IDLE':
      return 'Инициализация...';
    case 'MEDIA_LOADING':
      return 'Запрашиваем доступ к камере и микрофону...';
    case 'SIGNALING_CONNECT':
      return 'Подключаемся к серверу...';
    case 'WAITING_FOR_PEER':
      return 'Ожидаем подключение собеседника...';
    case 'NEGOTIATING':
      return 'Устанавливаем защищенное соединение...';
    case 'ACTIVE':
      return 'Звонок активен'; // Обычно этот текст не показывается, т.к. видео на весь экран
    case 'RECONNECTING':
      return 'Связь прервалась. Пытаемся восстановить...';
    case 'COMPLETED':
      return 'Звонок завершен.';
    case 'FAILED':
      return 'Произошла ошибка. Попробуйте обновить страницу.';
    default:
      return '';
  }
}

// Функция для получения цвета статуса (если нужно)
export function getStatusColor(state: AppCallState): string {
  if (state === 'FAILED' || state === 'RECONNECTING') return 'red';
  if (state === 'ACTIVE') return 'green';
  return 'gray';
}
```

### Почему это упрощает жизнь
1. **Безопасность**: Копирайтеры или фронтендеры могут менять тексты, не трогая сложную логику WebRTC.
2. **Локализация**: Если понадобится добавить английский язык, мы просто изменим эту одну функцию, добавив туда аргумент `locale`.
3. **Чистота кода**: В хуках останется только бизнес-логика (`state === 'failed'`), без визуального шума.

---

### Подробные подшаги выполнения

#### 5.1. Создание файла
- **Что сделать**: Создать новый файл `frontend/src/utils/callStatusUtils.ts`.

#### 5.2. Импорт типов
- **Что сделать**: Импортировать `AppCallState` из `services/types`.

#### 5.3. Написание функции сообщений
- **Что сделать**: Реализовать `getCallStatusMessage(state: AppCallState): string`.
- **Как**: Использовать конструкцию `switch (state)` или простой объект-словарь (Map), где ключи — состояния, а значения — тексты на русском языке.
- **Зачем**: Чтобы централизованно управлять текстами.

#### 5.4. (Опционально) Функция цветов
- **Что сделать**: Реализовать `getStatusColor(state)`, возвращающую CSS класс или код цвета (например, 'text-red-500' или '#ff0000').
- **Зачем**: Чтобы UI мог подсвечивать ошибки красным, а успех зеленым, не зная логики состояний.
